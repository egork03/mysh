/* Generated by re2c 3.0 */
#line 1 "lexer.re2c"
// Copyright (c) 2023 Egor Kosmachev
// Licensed under the MIT license.

#include "lexer.h"

char const* lexer(char const* cur, token_t* t)
{
	char const* YYMARKER;

    #line 15 "lexer.re2c"


	while(1)
	{
		char const* s = cur;

    
#line 21 "lexout.c"
{
	char yych;
	yych = *cur;
	if (yych <= 'C') {
		if (yych <= '%') {
			if (yych <= '\n') {
				if (yych <= 0x00) goto yy1;
				if (yych <= '\t') goto yy2;
			} else {
				if (yych == ' ') goto yy4;
				goto yy2;
			}
		} else {
			if (yych <= '<') {
				if (yych <= '&') goto yy5;
				if (yych <= ';') goto yy2;
				goto yy6;
			} else {
				if (yych == '>') goto yy7;
				if (yych <= 'B') goto yy2;
				goto yy8;
			}
		}
	} else {
		if (yych <= 'c') {
			if (yych <= 'O') {
				if (yych == 'E') goto yy9;
				goto yy2;
			} else {
				if (yych <= 'P') goto yy10;
				if (yych <= 'b') goto yy2;
				goto yy8;
			}
		} else {
			if (yych <= 'o') {
				if (yych == 'e') goto yy9;
				goto yy2;
			} else {
				if (yych <= 'p') goto yy10;
				if (yych == '|') goto yy11;
				goto yy2;
			}
		}
	}
yy1:
	++cur;
#line 25 "lexer.re2c"
	{
								--cur;
								token_compose(t, TOKEN_EOF, s, 0);
								return cur;
							}
#line 74 "lexout.c"
yy2:
	++cur;
yy3:
#line 78 "lexer.re2c"
	{
								goto path;
							}
#line 82 "lexout.c"
yy4:
	yych = *++cur;
	if (yych == ' ') goto yy4;
#line 31 "lexer.re2c"
	{ continue; }
#line 88 "lexout.c"
yy5:
	yych = *++cur;
	if (yych == '&') goto yy12;
	goto yy3;
yy6:
	++cur;
#line 52 "lexer.re2c"
	{
								token_compose(t, TOKEN_REDIRECTION_IN, s, 1);
								return cur;
							}
#line 100 "lexout.c"
yy7:
	++cur;
#line 58 "lexer.re2c"
	{
								token_compose(t, TOKEN_REDIRECTION_OUT, s, 1);
								return cur;
							}
#line 108 "lexout.c"
yy8:
	yych = *++cur;
	if (yych == 'D') goto yy13;
	if (yych == 'd') goto yy13;
	goto yy3;
yy9:
	yych = *(YYMARKER = ++cur);
	if (yych == 'X') goto yy14;
	if (yych == 'x') goto yy14;
	goto yy3;
yy10:
	yych = *(YYMARKER = ++cur);
	if (yych == 'W') goto yy16;
	if (yych == 'w') goto yy16;
	goto yy3;
yy11:
	yych = *++cur;
	if (yych == '|') goto yy17;
#line 63 "lexer.re2c"
	{
								token_compose(t, TOKEN_PIPE, s, 1);
								return cur;
							}
#line 132 "lexout.c"
yy12:
	++cur;
#line 73 "lexer.re2c"
	{
								token_compose(t, TOKEN_AND, s, 2);
								return cur;
							}
#line 140 "lexout.c"
yy13:
	++cur;
#line 34 "lexer.re2c"
	{
								token_compose(t, TOKEN_COMMAND_CD, s, 2);
								return cur;
							}
#line 148 "lexout.c"
yy14:
	yych = *++cur;
	if (yych == 'I') goto yy18;
	if (yych == 'i') goto yy18;
yy15:
	cur = YYMARKER;
	goto yy3;
yy16:
	yych = *++cur;
	if (yych == 'D') goto yy19;
	if (yych == 'd') goto yy19;
	goto yy15;
yy17:
	++cur;
#line 68 "lexer.re2c"
	{
								token_compose(t, TOKEN_OR, s, 2);
								return cur;
							}
#line 168 "lexout.c"
yy18:
	yych = *++cur;
	if (yych == 'T') goto yy20;
	if (yych == 't') goto yy20;
	goto yy15;
yy19:
	++cur;
#line 40 "lexer.re2c"
	{
								token_compose(t, TOKEN_COMMAND_PWD, s, 3);
								return cur;
							}
#line 181 "lexout.c"
yy20:
	++cur;
#line 46 "lexer.re2c"
	{
								token_compose(t, TOKEN_COMMAND_EXIT, s, 4);
								return cur;
							}
#line 189 "lexout.c"
}
#line 81 "lexer.re2c"


	}

path:
	;
	char const* path_start = cur - 1;
	while(1)
	{
    
#line 202 "lexout.c"
{
	char yych;
	yych = *cur;
	if (yych <= '&') {
		if (yych <= '\n') {
			if (yych <= 0x00) goto yy22;
			if (yych <= '\t') goto yy23;
		} else {
			if (yych == ' ') goto yy22;
			if (yych <= '%') goto yy23;
		}
	} else {
		if (yych <= '=') {
			if (yych != '<') goto yy23;
		} else {
			if (yych <= '>') goto yy22;
			if (yych != '|') goto yy23;
		}
	}
yy22:
	++cur;
#line 92 "lexer.re2c"
	{
								--cur;
								token_compose(t, TOKEN_PATH, path_start, cur - path_start);
								return cur;
							}
#line 230 "lexout.c"
yy23:
	++cur;
#line 99 "lexer.re2c"
	{
								continue;
							}
#line 237 "lexout.c"
}
#line 102 "lexer.re2c"


	}
}